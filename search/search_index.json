{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Get Started Welcome to the documentation of the data type registry developed in the scope of the FAIRCORE4EOSC project. The Typeregistry is based on the Cordra software developed by CNRI. Cordra is a software to manage digital objects and equip them with a persistent identifier. These digital objects are represented as JSON objects based on some previously defined JSON schema. In this typeregistry, some schemas are provided to cover many use cases. For more information on the provided schemas, refer to later pages in this documentation. Created types are equipped with a handle PID for unambigous identification of data types. Types can be created via the user interface or an API. For this, Cordra offers a REST API and a DOIP API for HTTP Clients. Documentation for these API's is provided by Cordra and can be found under the Documentation tab on the navigation bar. How the most basic operations can be used in the context of the Typeregistry can be found on the next page. To get started creating types, an account is necessary. As for now, no login via some external AAI provider is integrated in the typeregistry. Rather, a request has to be send for the admin to create an account for you. To request an account, please send a mail to support@pidconsortium.net . Should you just want to experiment with the provided schemas, we also offer the DTR-Playground . Here, the same interface with the same schemas is provided, but no persistent identifiers are generated for the data types and a user account is not required for the type creation. TypeAPI The TypeAPI is an additional service that is provided as part of the DTR component. Here, further functionalities are supplemented to types of the provided schemas to increase their effective use. These additional functionalities include the generation of validation schemas for types that qualify, filtering of types based on the measurement unit they use or which taxonomy node they are assigned to, and a federated search over mutltiple registries. These additional regisitries currently include the DTR- Test and the DTR-PIT by the pidconsortium. An extensive documentation of all available endpoints can also be found under the Documentation tab on the navigation bar.","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#get-started","text":"Welcome to the documentation of the data type registry developed in the scope of the FAIRCORE4EOSC project. The Typeregistry is based on the Cordra software developed by CNRI. Cordra is a software to manage digital objects and equip them with a persistent identifier. These digital objects are represented as JSON objects based on some previously defined JSON schema. In this typeregistry, some schemas are provided to cover many use cases. For more information on the provided schemas, refer to later pages in this documentation. Created types are equipped with a handle PID for unambigous identification of data types. Types can be created via the user interface or an API. For this, Cordra offers a REST API and a DOIP API for HTTP Clients. Documentation for these API's is provided by Cordra and can be found under the Documentation tab on the navigation bar. How the most basic operations can be used in the context of the Typeregistry can be found on the next page. To get started creating types, an account is necessary. As for now, no login via some external AAI provider is integrated in the typeregistry. Rather, a request has to be send for the admin to create an account for you. To request an account, please send a mail to support@pidconsortium.net . Should you just want to experiment with the provided schemas, we also offer the DTR-Playground . Here, the same interface with the same schemas is provided, but no persistent identifiers are generated for the data types and a user account is not required for the type creation.","title":"Get Started"},{"location":"#typeapi","text":"The TypeAPI is an additional service that is provided as part of the DTR component. Here, further functionalities are supplemented to types of the provided schemas to increase their effective use. These additional functionalities include the generation of validation schemas for types that qualify, filtering of types based on the measurement unit they use or which taxonomy node they are assigned to, and a federated search over mutltiple registries. These additional regisitries currently include the DTR- Test and the DTR-PIT by the pidconsortium. An extensive documentation of all available endpoints can also be found under the Documentation tab on the navigation bar.","title":"TypeAPI"},{"location":"Tutorials/apiIntro/","text":"Cordra API Introduction For the work with the typeregistry, the use of API's is an important feature to handle larger datasets or if you just have no need for the user interface. To begin, an account is necessary for most operations. Once you have an account, you can generate an access token using the following command: curl --request POST \\ --url 'http://typeregistry.lab.pidconsortium.net/auth/token' \\ --header 'Content-Type: application/json' \\ --data '{ \"grant_type\": \"password\", \"username\": \"\", \"password\": \"\" }' Enter your username and password in the designated fields. The token can be retrieved from the access_token field in the response. This token will stay active during your session and can be used for multiple requests. The retrieve command is one of the simplest ones and just requires the URL of the object you want to retrieve. Note that a # in front of objects in the URL would direct you to the UI version of the type. curl --request GET \\ --url 'http://typeregistry.lab.pidconsortium.net/objects/21.T11969/a41d30cdc6206b5a6fdd' \\ --header 'Content-Type: application/json' Some types are only visible for authorized users. For those types we will use the generated token to authenticate ourselves. This will be done in an 'Authorization' Header field, where TOKEN is the access token you generated for your account. curl --request GET \\ --url 'http://typeregistry.lab.pidconsortium.net/objects/21.T11969/0ea269895eceaf41f7d2' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Bearer TOKEN' Another important use of the API involves the creation of types via the API. This is helpful for larger batches of data or if you do not wish to work via the UI. Since Cordra stores types as JSON objects, we have to create JSON Objects based on the schemas provided. For more information on the schemas please refer to the respective sections in the documentations or view them directly under Types in the navigation bar. If you create a type via the API ist must be valid for the desired schema. An example for a type that is a valid BasicInfoType can be for example the following. Note that no field for id is given in the JSON object. This will be automatically filled and is part of the response. { \"name\": \"TestType\", \"provenance\": { \"contributors\": [ { \"Name\": \"Type Typerman\" } ], \"creationDate\": \"\", \"lastModificationDate\": \"\" }, \"ExpectedUse\": \"Will demonstrate API\", \"Aliases\": [ \"TestFile\" ], \"MeasuredUnits\": [ \"21.T11969/a41d30cdc6206b5a6fdd\" ], \"Schema\": { \"Type\": \"String\", \"Properties\": [ { \"Property\": \"minLength\", \"Value\": 0 }, { \"Property\": \"maxLength\", \"Value\": 10 } ] } } Consider this object saved on your disk as testType.json . To now create a type with that content consider the following command: curl --request POST \\ --url 'http://typeregistry.lab.pidconsortium.net/objects/?type=BasicInfoType' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Bearer TOKEN' \\ --data @\"testType.json\" Note that we need to authenticate the same way as before. The JSON object representing the type is simply passed as the content of the POST request. Of course it would also be possible to copy the actual JSON into the --data field, but referencing the file is a simpler way. For more information on the Cordra API refer to the links in the Documentation tab.","title":"Cordra API Tutorial"},{"location":"Tutorials/apiIntro/#cordra-api-introduction","text":"For the work with the typeregistry, the use of API's is an important feature to handle larger datasets or if you just have no need for the user interface. To begin, an account is necessary for most operations. Once you have an account, you can generate an access token using the following command: curl --request POST \\ --url 'http://typeregistry.lab.pidconsortium.net/auth/token' \\ --header 'Content-Type: application/json' \\ --data '{ \"grant_type\": \"password\", \"username\": \"\", \"password\": \"\" }' Enter your username and password in the designated fields. The token can be retrieved from the access_token field in the response. This token will stay active during your session and can be used for multiple requests. The retrieve command is one of the simplest ones and just requires the URL of the object you want to retrieve. Note that a # in front of objects in the URL would direct you to the UI version of the type. curl --request GET \\ --url 'http://typeregistry.lab.pidconsortium.net/objects/21.T11969/a41d30cdc6206b5a6fdd' \\ --header 'Content-Type: application/json' Some types are only visible for authorized users. For those types we will use the generated token to authenticate ourselves. This will be done in an 'Authorization' Header field, where TOKEN is the access token you generated for your account. curl --request GET \\ --url 'http://typeregistry.lab.pidconsortium.net/objects/21.T11969/0ea269895eceaf41f7d2' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Bearer TOKEN' Another important use of the API involves the creation of types via the API. This is helpful for larger batches of data or if you do not wish to work via the UI. Since Cordra stores types as JSON objects, we have to create JSON Objects based on the schemas provided. For more information on the schemas please refer to the respective sections in the documentations or view them directly under Types in the navigation bar. If you create a type via the API ist must be valid for the desired schema. An example for a type that is a valid BasicInfoType can be for example the following. Note that no field for id is given in the JSON object. This will be automatically filled and is part of the response. { \"name\": \"TestType\", \"provenance\": { \"contributors\": [ { \"Name\": \"Type Typerman\" } ], \"creationDate\": \"\", \"lastModificationDate\": \"\" }, \"ExpectedUse\": \"Will demonstrate API\", \"Aliases\": [ \"TestFile\" ], \"MeasuredUnits\": [ \"21.T11969/a41d30cdc6206b5a6fdd\" ], \"Schema\": { \"Type\": \"String\", \"Properties\": [ { \"Property\": \"minLength\", \"Value\": 0 }, { \"Property\": \"maxLength\", \"Value\": 10 } ] } } Consider this object saved on your disk as testType.json . To now create a type with that content consider the following command: curl --request POST \\ --url 'http://typeregistry.lab.pidconsortium.net/objects/?type=BasicInfoType' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Bearer TOKEN' \\ --data @\"testType.json\" Note that we need to authenticate the same way as before. The JSON object representing the type is simply passed as the content of the POST request. Of course it would also be possible to copy the actual JSON into the --data field, but referencing the file is a simpler way. For more information on the Cordra API refer to the links in the Documentation tab.","title":"Cordra API Introduction"},{"location":"creatingTypes/acl/","text":"Managing Access Managing Access Control","title":"Managing Access Control"},{"location":"creatingTypes/acl/#managing-access","text":"Managing Access Control","title":"Managing Access"},{"location":"creatingTypes/schemaTypeTutorial/","text":"Creating Schema Elements from Scratch One main application of the Data Type Registry is the creation of metadata elements of schemas. Registering metadata elements has many advantages. These include the unambigious identification via a PID, additional metadata information, and the possibility of reusability and interoperability of types. In this tutorial, we will walk through the entire creation of schema elements, starting with the fundamental building blocks and ending at the generation of JSON schemas of complex data types. What are Schema Elements in the DTR? When clicking Create , the possible types that are available can seem overwhelming at first. That is why we want to shed some light on the kinds of data types relevant for the creation of schema elements. In general, we differentiate between two different structures with different responsibilities. BasicInfoTypes can be considered the basic building blocks, or leaf nodes, for schema elements. Each BasicInfoType is simply some fundamental data type, with additional metadata and the possibility to apply some restrictions on that type. An InfoType on the other hand is a more complex construct. It shares the set of metadata with BasicInfoTypes , but instead of a fundamental data type it represents a composite of other types. It can either take the form of an Object , which is basically a set of key - value pairs where the values are other types, or an Array , where one type can be repeated. The Tuple property will be implemented soon. The following table gives a quick overview over which type can represent what: BasicInfoType InfoType String Object Number Array Boolean Tuple We will start now by creating a BasicInfoType to descibe a single property of an existing metadata schema. Creating a BasicInfoType For the creation of our BasicInfoType we will use an actual metadata schema as a blueprint. This hopefully helps in following along the parallels and how the schema is created hierarchically in the DTR. Take a look at the following schema from KonsortSWD, which develop infrastructure for research data for the social sciences in the scope of the NFDI. When untangling the $ref properties we see that the schema is basically an object containing just an array called variables , where each variable has a number of properties. To now recreate this schema in the DTR we have to start from the bottom and gradually build the schema up hierarchically. So let us zoom in on one of those basic properties, the first one in the list: \"studyDOI\": {\"type\": \"string\",\"pattern\": \"[1][0][/.].*\"}, We see that it represents the fundamental data type string and applies a restriction in the form of a regular expression, just called pattern in JSON-Schema. Now we want to create this property as BasicInfoType in the DTR. Of course this is all possible via the API, but we consider the process via the UI for now. Take a look at tje [] Generating a JSON Schema Lorem Ipsum Creating an Info Type Effects of the different fields on the Schema","title":"Creating Schema Elements from Scratch"},{"location":"creatingTypes/schemaTypeTutorial/#creating-schema-elements-from-scratch","text":"One main application of the Data Type Registry is the creation of metadata elements of schemas. Registering metadata elements has many advantages. These include the unambigious identification via a PID, additional metadata information, and the possibility of reusability and interoperability of types. In this tutorial, we will walk through the entire creation of schema elements, starting with the fundamental building blocks and ending at the generation of JSON schemas of complex data types.","title":"Creating Schema Elements from Scratch"},{"location":"creatingTypes/schemaTypeTutorial/#what-are-schema-elements-in-the-dtr","text":"When clicking Create , the possible types that are available can seem overwhelming at first. That is why we want to shed some light on the kinds of data types relevant for the creation of schema elements. In general, we differentiate between two different structures with different responsibilities. BasicInfoTypes can be considered the basic building blocks, or leaf nodes, for schema elements. Each BasicInfoType is simply some fundamental data type, with additional metadata and the possibility to apply some restrictions on that type. An InfoType on the other hand is a more complex construct. It shares the set of metadata with BasicInfoTypes , but instead of a fundamental data type it represents a composite of other types. It can either take the form of an Object , which is basically a set of key - value pairs where the values are other types, or an Array , where one type can be repeated. The Tuple property will be implemented soon. The following table gives a quick overview over which type can represent what: BasicInfoType InfoType String Object Number Array Boolean Tuple We will start now by creating a BasicInfoType to descibe a single property of an existing metadata schema.","title":"What are Schema Elements in the DTR?"},{"location":"creatingTypes/schemaTypeTutorial/#creating-a-basicinfotype","text":"For the creation of our BasicInfoType we will use an actual metadata schema as a blueprint. This hopefully helps in following along the parallels and how the schema is created hierarchically in the DTR. Take a look at the following schema from KonsortSWD, which develop infrastructure for research data for the social sciences in the scope of the NFDI. When untangling the $ref properties we see that the schema is basically an object containing just an array called variables , where each variable has a number of properties. To now recreate this schema in the DTR we have to start from the bottom and gradually build the schema up hierarchically. So let us zoom in on one of those basic properties, the first one in the list: \"studyDOI\": {\"type\": \"string\",\"pattern\": \"[1][0][/.].*\"}, We see that it represents the fundamental data type string and applies a restriction in the form of a regular expression, just called pattern in JSON-Schema. Now we want to create this property as BasicInfoType in the DTR. Of course this is all possible via the API, but we consider the process via the UI for now. Take a look at tje []","title":"Creating a BasicInfoType"},{"location":"creatingTypes/schemaTypeTutorial/#generating-a-json-schema","text":"Lorem Ipsum","title":"Generating a JSON Schema"},{"location":"creatingTypes/schemaTypeTutorial/#creating-an-info-type","text":"","title":"Creating an Info Type"},{"location":"creatingTypes/schemaTypeTutorial/#effects-of-the-different-fields-on-the-schema","text":"","title":"Effects of the different fields on the Schema"},{"location":"creatingTypes/typeCreation/","text":"Type Creation Here we will walk through the process of creating a new type in the Data Type Registry. This guide focuses on the use of the UI, but the process can also be done via the API. It is helpful though to use the UI first to get an understanding of the structure of types and what is necessary to construct them. General While the different data types serve different purposes, they share some common features. Here we will explain how to create the most common elements of a Data Type, such as descriptive meta. After name and description, users can versionize their data types. For this, you can enter a Version , a Previous Version and a Next Version . The fields for previous and next version need to be PIDs referencing other BasicInfoTypes or InfoTypes registered in the DTR. You can use the UI to navigate between versions, or use the TypeAPI for further versioning features. Creating versions of a Data Type The Expected Use field is a short description of how the type should be used. This serves mostly as a reference for the user and especially other users who look for reusable types for their own project. How the type should be used A list of external references can be added to the type. This can be used to link to other types in the DTR, but also to external resources that are not part of the DTR. This is can be helpful for future reference if already existing resources are being registered in the DTR or, for example, an RFC is implemented. External References Aliases can be added to the type. This serves on one hand as information for other users who may know the type under a different name, and simply as tags to find the type more easily using the search features. Aliases of a Data Type Each type can be assigned one or many TaxonomyNodes . This can be used to group types together in a way that is more semantically meaningful. The Query Builder can be used to filter results based on the assigned TaxonomyNodes , or the TypeAPI can be used to group types hierarchically based on the hierarchical structure of the underlying taxonomy nodes. Custom Facets for a Type BasicInfoTypes BasicInfoTypes can be considered the basic building blocks, or leaf nodes, for schema elements. Each BasicInfoType is simply some fundamental data type, with additional metadata and the possibility to apply some restrictions on that type. As additional metadata field, a Measurement Unit can be added to a BasicInfoType . This unit should also be registered in the DTR. This has no inherent functionality beyond the ability to use the unit as additional facet, but can prove helpful for future applications, for example conversions between types based on their measurement units. Measurement Units for Basic Types The fundamental type of a BasicInfoType can be selected from the following list. Note here that Enum is an additional category. This is because an enum can be of mixed values and external references. Options for Basic Types A BasicInfoType can be assigned a set of properties to further restrict the fundamental type it represents. Usually, users want a set of properties to be applied to a type, but there are also some cases where properties need to be chained differently using logical operators. By default, the AND operator is used, but this can be changed to OR or XOR operators. Use cases for different operators are for example allowing different date formats for a type. How to chain the properties. Each property is basically a key - value pair, with the key being the name of the property and the value being the value of the property. Since the main application of schema elements is to generate JSON schemas, the keys follow the JSON Schema specification . With the custom keyword, addition or special properties can be added. Note that generation of valid schemas with the TypeAPI can not be guaranteed to work if custom properties are used. Example for a basic Property. One special property is the $ref keyword for enums. Even though $ref can be in theory used to include anything into a JSON schema, we want to restrict its usage to enum references. This way, large or frequently changing lists of values can be managed outside the DTR and included using a URL. Note that the content behind the URL must be a valid JSON enum. Enum Reference. InfoTypes InfoTypes either combine one or multiple other Types, or represent a collection of multiple instances of the same Type. This includes both other InfoTypes or BasicInfoTypes. Thus, InfoTypes can be of two types: object and array . Note that Profiles have no individual section here, since they share all syntactic properties with InfoTypes , but can only take the form of objects . If the type object is selected, subschema conditions can be applied to the resulting schema, which can also be considered boolean schema combinations. Note here a common misconception when using the allOf keyword: This does not describe that all of the properties in an InfoType must be present, but rather that all of the subschemas must be valid. So, when validating data against the schema, it must validate against each subschema individually. Subschema Conditions. The name keyword also serves as the name of the property in the JSON schema. Name of the property. The Title and Description fields are mostly for use in the resulting JSON schema. If no description is provided, the description for the field in the schema will be extracted from the underlying type, if available. Title and description for the JSON Schema. A PID reference to another Data Type registered in the DTR must be given in the type keyword. Type of the property. The optional const keyword can be used to add a constant value to the property. This should mostly be used if the underlying type is a BasicInfoType . Constant value for the field. If the InfoType is an object, the cardinality keyword can be used to specify the cardinality of the current property. If the property should be used as a simple array without special properties, the cardinality can be used to generate an array in the JSON schema. Note that cardinality 1 and cardinality 1 - n describe mandatory elements or arrays respectively. Cardinality for the property. The Extract Properties keyword is an advanced feature for constructing complex objects. It can only be used if the underlying type of the property is an InfoType or a Profile , otherwise it has no effect. The keywords effect on a resulting JSON Schema is, that it does not add the referenced type as a property, but rather extracts the properties from the referenced type and adds them individually. This can be a useful tool to expand an existing profile or complex type without needing to reference all individual properties again. Extraction of Properties. As a better explanation consider the following examples of JSON schemas generated from a type. Both types have two properties, a simple string called TetstStringSecond which is a BasicInfoType , and and InfoType object called testObject , which has as its property the same BasicInfoType called testString . In the first example, we do not extact properties and the object is added as a property to the resulting schema. In the second example, we extract the properties from the InfoType and add them as properties to the resulting schema, so both testString and testStringSecond are on the same level. { \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"@id\": \"21.T11969/cb692fd330999796d709\", \"additionalProperties\": false, \"properties\": { \"testObject\": { \"@id\": \"21.T11969/94ab75cda0af87cd2172\", \"additionalProperties\": false, \"properties\": { \"testString\": { \"@id\": \"21.T11969/3df63b7acb0522da685d\", \"type\": \"string\" } }, \"type\": \"object\" }, \"testStringSecond\": { \"@id\": \"21.T11969/3df63b7acb0522da685d\", \"type\": \"string\" } }, \"title\": \"extractProperties\", \"type\": \"object\" } ExtractProperties = false { \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"@id\": \"21.T11969/94ab75cda0af87cd2172\", \"additionalProperties\": false, \"properties\": { \"testString\": { \"@id\": \"21.T11969/3df63b7acb0522da685d\", \"type\": \"string\" }, \"testStringSecond\": { \"@id\": \"21.T11969/3df63b7acb0522da685d\", \"type\": \"string\" } }, \"title\": \"Test\", \"type\": \"object\" } ExtractProperties = true TaxonomyNodes TaxonomyNodes share all general metadata properties with the other types, but can have a set of Parent Nodes assigned to them, which serve as a way to construct simple hierarchies. Parent Nodes of Taxonomy Node.","title":"Type Creation"},{"location":"creatingTypes/typeCreation/#type-creation","text":"Here we will walk through the process of creating a new type in the Data Type Registry. This guide focuses on the use of the UI, but the process can also be done via the API. It is helpful though to use the UI first to get an understanding of the structure of types and what is necessary to construct them.","title":"Type Creation"},{"location":"creatingTypes/typeCreation/#general","text":"While the different data types serve different purposes, they share some common features. Here we will explain how to create the most common elements of a Data Type, such as descriptive meta. After name and description, users can versionize their data types. For this, you can enter a Version , a Previous Version and a Next Version . The fields for previous and next version need to be PIDs referencing other BasicInfoTypes or InfoTypes registered in the DTR. You can use the UI to navigate between versions, or use the TypeAPI for further versioning features. Creating versions of a Data Type The Expected Use field is a short description of how the type should be used. This serves mostly as a reference for the user and especially other users who look for reusable types for their own project. How the type should be used A list of external references can be added to the type. This can be used to link to other types in the DTR, but also to external resources that are not part of the DTR. This is can be helpful for future reference if already existing resources are being registered in the DTR or, for example, an RFC is implemented. External References Aliases can be added to the type. This serves on one hand as information for other users who may know the type under a different name, and simply as tags to find the type more easily using the search features. Aliases of a Data Type Each type can be assigned one or many TaxonomyNodes . This can be used to group types together in a way that is more semantically meaningful. The Query Builder can be used to filter results based on the assigned TaxonomyNodes , or the TypeAPI can be used to group types hierarchically based on the hierarchical structure of the underlying taxonomy nodes. Custom Facets for a Type","title":"General"},{"location":"creatingTypes/typeCreation/#basicinfotypes","text":"BasicInfoTypes can be considered the basic building blocks, or leaf nodes, for schema elements. Each BasicInfoType is simply some fundamental data type, with additional metadata and the possibility to apply some restrictions on that type. As additional metadata field, a Measurement Unit can be added to a BasicInfoType . This unit should also be registered in the DTR. This has no inherent functionality beyond the ability to use the unit as additional facet, but can prove helpful for future applications, for example conversions between types based on their measurement units. Measurement Units for Basic Types The fundamental type of a BasicInfoType can be selected from the following list. Note here that Enum is an additional category. This is because an enum can be of mixed values and external references. Options for Basic Types A BasicInfoType can be assigned a set of properties to further restrict the fundamental type it represents. Usually, users want a set of properties to be applied to a type, but there are also some cases where properties need to be chained differently using logical operators. By default, the AND operator is used, but this can be changed to OR or XOR operators. Use cases for different operators are for example allowing different date formats for a type. How to chain the properties. Each property is basically a key - value pair, with the key being the name of the property and the value being the value of the property. Since the main application of schema elements is to generate JSON schemas, the keys follow the JSON Schema specification . With the custom keyword, addition or special properties can be added. Note that generation of valid schemas with the TypeAPI can not be guaranteed to work if custom properties are used. Example for a basic Property. One special property is the $ref keyword for enums. Even though $ref can be in theory used to include anything into a JSON schema, we want to restrict its usage to enum references. This way, large or frequently changing lists of values can be managed outside the DTR and included using a URL. Note that the content behind the URL must be a valid JSON enum. Enum Reference.","title":"BasicInfoTypes"},{"location":"creatingTypes/typeCreation/#infotypes","text":"InfoTypes either combine one or multiple other Types, or represent a collection of multiple instances of the same Type. This includes both other InfoTypes or BasicInfoTypes. Thus, InfoTypes can be of two types: object and array . Note that Profiles have no individual section here, since they share all syntactic properties with InfoTypes , but can only take the form of objects . If the type object is selected, subschema conditions can be applied to the resulting schema, which can also be considered boolean schema combinations. Note here a common misconception when using the allOf keyword: This does not describe that all of the properties in an InfoType must be present, but rather that all of the subschemas must be valid. So, when validating data against the schema, it must validate against each subschema individually. Subschema Conditions. The name keyword also serves as the name of the property in the JSON schema. Name of the property. The Title and Description fields are mostly for use in the resulting JSON schema. If no description is provided, the description for the field in the schema will be extracted from the underlying type, if available. Title and description for the JSON Schema. A PID reference to another Data Type registered in the DTR must be given in the type keyword. Type of the property. The optional const keyword can be used to add a constant value to the property. This should mostly be used if the underlying type is a BasicInfoType . Constant value for the field. If the InfoType is an object, the cardinality keyword can be used to specify the cardinality of the current property. If the property should be used as a simple array without special properties, the cardinality can be used to generate an array in the JSON schema. Note that cardinality 1 and cardinality 1 - n describe mandatory elements or arrays respectively. Cardinality for the property. The Extract Properties keyword is an advanced feature for constructing complex objects. It can only be used if the underlying type of the property is an InfoType or a Profile , otherwise it has no effect. The keywords effect on a resulting JSON Schema is, that it does not add the referenced type as a property, but rather extracts the properties from the referenced type and adds them individually. This can be a useful tool to expand an existing profile or complex type without needing to reference all individual properties again. Extraction of Properties. As a better explanation consider the following examples of JSON schemas generated from a type. Both types have two properties, a simple string called TetstStringSecond which is a BasicInfoType , and and InfoType object called testObject , which has as its property the same BasicInfoType called testString . In the first example, we do not extact properties and the object is added as a property to the resulting schema. In the second example, we extract the properties from the InfoType and add them as properties to the resulting schema, so both testString and testStringSecond are on the same level. { \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"@id\": \"21.T11969/cb692fd330999796d709\", \"additionalProperties\": false, \"properties\": { \"testObject\": { \"@id\": \"21.T11969/94ab75cda0af87cd2172\", \"additionalProperties\": false, \"properties\": { \"testString\": { \"@id\": \"21.T11969/3df63b7acb0522da685d\", \"type\": \"string\" } }, \"type\": \"object\" }, \"testStringSecond\": { \"@id\": \"21.T11969/3df63b7acb0522da685d\", \"type\": \"string\" } }, \"title\": \"extractProperties\", \"type\": \"object\" } ExtractProperties = false { \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"@id\": \"21.T11969/94ab75cda0af87cd2172\", \"additionalProperties\": false, \"properties\": { \"testString\": { \"@id\": \"21.T11969/3df63b7acb0522da685d\", \"type\": \"string\" }, \"testStringSecond\": { \"@id\": \"21.T11969/3df63b7acb0522da685d\", \"type\": \"string\" } }, \"title\": \"Test\", \"type\": \"object\" } ExtractProperties = true","title":"InfoTypes"},{"location":"creatingTypes/typeCreation/#taxonomynodes","text":"TaxonomyNodes share all general metadata properties with the other types, but can have a set of Parent Nodes assigned to them, which serve as a way to construct simple hierarchies. Parent Nodes of Taxonomy Node.","title":"TaxonomyNodes"},{"location":"creatingTypes/types/","text":"The Different Data Types This page explains the purpose of the different data types that can be created in the typeregistry. Schema Elements One main application of the Data Type Registry is the creation of metadata elements of schemas. Registering metadata elements has many advantages. These include the unambigious identification via a PID, additional metadata information, and the possibility of reusability and interoperability of types. Basic Info Types BasicInfoTypes can be considered the basic building blocks, or leaf nodes, for schema elements. Each BasicInfoType is simply some fundamental data type, with additional metadata and the possibility to apply some restrictions on that type. BasicInfoType String Number Boolean Enum Info Types An InfoType on the other hand is a more complex construct. It shares the set of metadata with BasicInfoTypes , but instead of a fundamental data type it represents a composite of other types. It can either take the form of an Object , which is basically a is a collection of BasicInfoTypes and InfoTypes that are used to create a new InfoType , or an Array , where one type can be repeated. The Tuple property will be implemented soon. InfoType Object Array Tuple Profiles Syntactically, a Profile is similar to an InfoType , but it differs semantically. A Profile can only be an object and represents a full schema or kernel information profile (KIP). Taxonomy Nodes Taxonomy Nodes can be used to group types together in a way that is more semantically meaningful. Each Taxonomy Node represents just a term with potential parent nodes. This way, Taxonomy Nodes can be hierarchically organized. Each other kind of data type can be assigned one or more taxonomy nodes, which can used as custom facets either in the query builder or in the Type API, where the hierarchical nature of the taxonomy nodes can be used to filter results. Measurement Units The DTR offers rudimentary support for measurement units. They can be registered with minimal information assigned to BasicInfoTypes . The DTR is not supposed to be a ground truth registry for measurement units, but they serve to enrich other types with more semantic information. Extended MIME Types In a proof of concept, the DTR includes the ability to register extended MIME types. The entire collection of Media Types from IANA is included in the DTR in machine actionable format and with additional metadata enriched.","title":"The Different Data Types"},{"location":"creatingTypes/types/#the-different-data-types","text":"This page explains the purpose of the different data types that can be created in the typeregistry.","title":"The Different Data Types"},{"location":"creatingTypes/types/#schema-elements","text":"One main application of the Data Type Registry is the creation of metadata elements of schemas. Registering metadata elements has many advantages. These include the unambigious identification via a PID, additional metadata information, and the possibility of reusability and interoperability of types.","title":"Schema Elements"},{"location":"creatingTypes/types/#basic-info-types","text":"BasicInfoTypes can be considered the basic building blocks, or leaf nodes, for schema elements. Each BasicInfoType is simply some fundamental data type, with additional metadata and the possibility to apply some restrictions on that type. BasicInfoType String Number Boolean Enum","title":"Basic Info Types"},{"location":"creatingTypes/types/#info-types","text":"An InfoType on the other hand is a more complex construct. It shares the set of metadata with BasicInfoTypes , but instead of a fundamental data type it represents a composite of other types. It can either take the form of an Object , which is basically a is a collection of BasicInfoTypes and InfoTypes that are used to create a new InfoType , or an Array , where one type can be repeated. The Tuple property will be implemented soon. InfoType Object Array Tuple","title":"Info Types"},{"location":"creatingTypes/types/#profiles","text":"Syntactically, a Profile is similar to an InfoType , but it differs semantically. A Profile can only be an object and represents a full schema or kernel information profile (KIP).","title":"Profiles"},{"location":"creatingTypes/types/#taxonomy-nodes","text":"Taxonomy Nodes can be used to group types together in a way that is more semantically meaningful. Each Taxonomy Node represents just a term with potential parent nodes. This way, Taxonomy Nodes can be hierarchically organized. Each other kind of data type can be assigned one or more taxonomy nodes, which can used as custom facets either in the query builder or in the Type API, where the hierarchical nature of the taxonomy nodes can be used to filter results.","title":"Taxonomy Nodes"},{"location":"creatingTypes/types/#measurement-units","text":"The DTR offers rudimentary support for measurement units. They can be registered with minimal information assigned to BasicInfoTypes . The DTR is not supposed to be a ground truth registry for measurement units, but they serve to enrich other types with more semantic information.","title":"Measurement Units"},{"location":"creatingTypes/types/#extended-mime-types","text":"In a proof of concept, the DTR includes the ability to register extended MIME types. The entire collection of Media Types from IANA is included in the DTR in machine actionable format and with additional metadata enriched.","title":"Extended MIME Types"},{"location":"creatingTypes/ui_auth/","text":"Navigation and Authentication This section will provide a quick overview of the navigation and authentication features of the Data Type Registry. Authentication The External authentication options While exploration of registered types is possible without authentication, the ability to create, update and delete types is restricted to authenticated users. Local accounts can be requested via a mail to support@pidconsortium.net, but users also have the ability to authenticate via an external AAI provider. Authentication is possible via the EOSC Innocation Sandbox, which is currently in beta status, or the Academic Cloud, a service portal for Lower Saxony where account creation is possible for everyone. A User ID After authentication, your unique User ID will be displayed on the top navigation. This ID will identify you as creator of types, and can be used in managing access control of types. Navigation High level navigation in the DTR is mostly done via the top navigation bar. In the following section, the different options available to users are described. The Navigation Bar Queries All Objects This displays all types that have been registered in the Data Type Registry, by default sorted by their last modification, so displaying the most recently modified types first. Query Builder Although complex queries can be entered in the search bar (refer to the Cordra documentation for the query syntax), the query builder can be used to construct moderately complex queries, using creator, kind of type, and taxonomy nodes as facets just using the UI. Show Only This option can be used to show all types from a certain kind. Types Here users can view the underlying schemas for the different kinds of types. Documentation Opens this documentation. Resources Type API This shows the Swagger UI page for the TypeAPI, which is an additional service that is provided as part of the Data Type Registry component. For a more in-depth description of the TypeAPI, please refer to the TypeAPI Documentation page . Cordra DOIP API Displays how to use the Digital Object Interface Protocol (DOIP) via HTTP to use the Cordra API. Cordra REST API Shows how to use the REST endpoints of the Cordra API.","title":"Navigation and Authentication"},{"location":"creatingTypes/ui_auth/#navigation-and-authentication","text":"This section will provide a quick overview of the navigation and authentication features of the Data Type Registry.","title":"Navigation and Authentication"},{"location":"creatingTypes/ui_auth/#authentication","text":"The External authentication options While exploration of registered types is possible without authentication, the ability to create, update and delete types is restricted to authenticated users. Local accounts can be requested via a mail to support@pidconsortium.net, but users also have the ability to authenticate via an external AAI provider. Authentication is possible via the EOSC Innocation Sandbox, which is currently in beta status, or the Academic Cloud, a service portal for Lower Saxony where account creation is possible for everyone. A User ID After authentication, your unique User ID will be displayed on the top navigation. This ID will identify you as creator of types, and can be used in managing access control of types.","title":"Authentication"},{"location":"creatingTypes/ui_auth/#navigation","text":"High level navigation in the DTR is mostly done via the top navigation bar. In the following section, the different options available to users are described. The Navigation Bar","title":"Navigation"},{"location":"creatingTypes/ui_auth/#queries","text":"","title":"Queries"},{"location":"creatingTypes/ui_auth/#all-objects","text":"This displays all types that have been registered in the Data Type Registry, by default sorted by their last modification, so displaying the most recently modified types first.","title":"All Objects"},{"location":"creatingTypes/ui_auth/#query-builder","text":"Although complex queries can be entered in the search bar (refer to the Cordra documentation for the query syntax), the query builder can be used to construct moderately complex queries, using creator, kind of type, and taxonomy nodes as facets just using the UI.","title":"Query Builder"},{"location":"creatingTypes/ui_auth/#show-only","text":"This option can be used to show all types from a certain kind.","title":"Show Only"},{"location":"creatingTypes/ui_auth/#types","text":"Here users can view the underlying schemas for the different kinds of types.","title":"Types"},{"location":"creatingTypes/ui_auth/#documentation","text":"Opens this documentation.","title":"Documentation"},{"location":"creatingTypes/ui_auth/#resources","text":"","title":"Resources"},{"location":"creatingTypes/ui_auth/#type-api","text":"This shows the Swagger UI page for the TypeAPI, which is an additional service that is provided as part of the Data Type Registry component. For a more in-depth description of the TypeAPI, please refer to the TypeAPI Documentation page .","title":"Type API"},{"location":"creatingTypes/ui_auth/#cordra-doip-api","text":"Displays how to use the Digital Object Interface Protocol (DOIP) via HTTP to use the Cordra API.","title":"Cordra DOIP API"},{"location":"creatingTypes/ui_auth/#cordra-rest-api","text":"Shows how to use the REST endpoints of the Cordra API.","title":"Cordra REST API"},{"location":"creatingTypes/validation/","text":"Schema Generation and Validating Data","title":"Schema Generation and Validating Data"},{"location":"creatingTypes/validation/#schema-generation-and-validating-data","text":"","title":"Schema Generation and Validating Data"},{"location":"schemas/Overview/","text":"Schemas Overview All schemas that are included in the Typeregistry share a common set of metadata that are used to describe the types. For an easier overview, this set of metadata is described here once and omitted from the individual definitions. General Schema name please use printable ascii characters without blank Type: string path: #/properties/name The value must match this pattern: ^([!-~])+$ Length: \u2264 256 description Type: string path: #/properties/description The value must match this pattern: (.|)* Length: \u2264 8192 versioning Type: object path: #/properties/versioning Properties version Type: string path: #/properties/versioning/properties/version previousVersion path: #/properties/versioning/properties/previousVersion nextVersion path: #/properties/versioning/properties/nextVersion provenance Type: object path: #/properties/provenance Properties contributors Type: array path: #/properties/provenance/properties/contributors Items Type: object path: #/properties/provenance/properties/contributors/items Properties Name Full name of the contributor Type: string path: #/properties/provenance/properties/contributors/items/properties/Name ORCID Type: string path: #/properties/provenance/properties/contributors/items/properties/ORCID creationDate Type: string path: #/properties/provenance/properties/creationDate String format must be a \"datetime\" lastModificationDate Type: string path: #/properties/provenance/properties/lastModificationDate String format must be a \"datetime\" ExpectedUse Type: string path: #/properties/ExpectedUse String format must be a \"textarea\" Length: \u2264 1024 Aliases Provide a list of aliases as alternatives to the chosen name. Type: array path: #/properties/Aliases Items Type: string path: #/properties/Aliases/items","title":"Overview"},{"location":"schemas/Overview/#schemas-overview","text":"All schemas that are included in the Typeregistry share a common set of metadata that are used to describe the types. For an easier overview, this set of metadata is described here once and omitted from the individual definitions.","title":"Schemas Overview"},{"location":"schemas/Overview/#general-schema","text":"name please use printable ascii characters without blank Type: string path: #/properties/name The value must match this pattern: ^([!-~])+$ Length: \u2264 256 description Type: string path: #/properties/description The value must match this pattern: (.|)* Length: \u2264 8192 versioning Type: object path: #/properties/versioning Properties version Type: string path: #/properties/versioning/properties/version previousVersion path: #/properties/versioning/properties/previousVersion nextVersion path: #/properties/versioning/properties/nextVersion provenance Type: object path: #/properties/provenance Properties contributors Type: array path: #/properties/provenance/properties/contributors Items Type: object path: #/properties/provenance/properties/contributors/items Properties Name Full name of the contributor Type: string path: #/properties/provenance/properties/contributors/items/properties/Name ORCID Type: string path: #/properties/provenance/properties/contributors/items/properties/ORCID creationDate Type: string path: #/properties/provenance/properties/creationDate String format must be a \"datetime\" lastModificationDate Type: string path: #/properties/provenance/properties/lastModificationDate String format must be a \"datetime\" ExpectedUse Type: string path: #/properties/ExpectedUse String format must be a \"textarea\" Length: \u2264 1024 Aliases Provide a list of aliases as alternatives to the chosen name. Type: array path: #/properties/Aliases Items Type: string path: #/properties/Aliases/items","title":"General Schema"},{"location":"schemas/basictype/","text":"BasicInfoType The BasicInfoType is used to represent any datatype that is some form of a fundamental type, namely strings, numbers, booleans. When restrictions are properly filled, a validation schema can be generated for each BasicInfoType. Schema All fields from the General Schema are included MeasuredUnits Units that are measured using this type. Type: array path: #/properties/MeasuredUnits Items path: #/properties/MeasuredUnits/items Taxonomies Taxonomy nodes that this type should be assigned to. Type: array path: #/properties/Taxonomies Items path: #/properties/Taxonomies/items Schema Select the fundamental datatype this type should represent. \"Number\" can be further differentiated into integer and float. Type: object path: #/properties/Schema Properties The properties of the schema branch here into different directions based on the desired fundamental datatype. For each fundamental type, different restrictions are valid and internal validation is conducted accordingly. We now list the possibilities for each datatype. Type required For type \"Number\", further differentiate between integer and float. Type: string path: #/properties/Test/properties/Type The value is restricted to the following: \"String\" \"Integer\" \"Number\" \"Boolean\" \"Enum\" \"None\" PropRelations Properties are chained by boolean operators. By default, through the AND operator all properties must apply. OR or XOR operators for properties are also possible. Type: string path: #/properties/Test/properties/PropRelations The value is restricted to the following: \"AND\" \"OR\" \"XOR\" Properties Type: array/string path: #/properties/Test/properties/Properties The allowed values in the properties field depend on the desired fundamental type. Strings, Integers and Numbers have an array like described in the items field below. Note that when using field names described by the json-schema definition (i.e. minLength, maxLength...) the values are validated internally to avoid issues on the schema creation. Items Type: object path: #/properties/Test/properties/Properties/items Properties Property Type: string path: #/properties/Property Value - Type: string - path: #/properties/Value If the selected Type is boolean , the Properties field is only one optional string, which may take one of the following two values. Type: string \"Always True\" \"Always False\" Type: string path: #/properties/Property The value is restricted to the following: \"Integer Enum\" - Value Type: array path: #/properties/Value Items Enum Element Type: integer path: #/properties/Value/items","title":"Basic Types"},{"location":"schemas/basictype/#basicinfotype","text":"The BasicInfoType is used to represent any datatype that is some form of a fundamental type, namely strings, numbers, booleans. When restrictions are properly filled, a validation schema can be generated for each BasicInfoType.","title":"BasicInfoType"},{"location":"schemas/basictype/#schema","text":"All fields from the General Schema are included MeasuredUnits Units that are measured using this type. Type: array path: #/properties/MeasuredUnits Items path: #/properties/MeasuredUnits/items Taxonomies Taxonomy nodes that this type should be assigned to. Type: array path: #/properties/Taxonomies Items path: #/properties/Taxonomies/items Schema Select the fundamental datatype this type should represent. \"Number\" can be further differentiated into integer and float. Type: object path: #/properties/Schema Properties The properties of the schema branch here into different directions based on the desired fundamental datatype. For each fundamental type, different restrictions are valid and internal validation is conducted accordingly. We now list the possibilities for each datatype. Type required For type \"Number\", further differentiate between integer and float. Type: string path: #/properties/Test/properties/Type The value is restricted to the following: \"String\" \"Integer\" \"Number\" \"Boolean\" \"Enum\" \"None\" PropRelations Properties are chained by boolean operators. By default, through the AND operator all properties must apply. OR or XOR operators for properties are also possible. Type: string path: #/properties/Test/properties/PropRelations The value is restricted to the following: \"AND\" \"OR\" \"XOR\" Properties Type: array/string path: #/properties/Test/properties/Properties The allowed values in the properties field depend on the desired fundamental type. Strings, Integers and Numbers have an array like described in the items field below. Note that when using field names described by the json-schema definition (i.e. minLength, maxLength...) the values are validated internally to avoid issues on the schema creation. Items Type: object path: #/properties/Test/properties/Properties/items Properties Property Type: string path: #/properties/Property Value - Type: string - path: #/properties/Value If the selected Type is boolean , the Properties field is only one optional string, which may take one of the following two values. Type: string \"Always True\" \"Always False\" Type: string path: #/properties/Property The value is restricted to the following: \"Integer Enum\" - Value Type: array path: #/properties/Value Items","title":"Schema"},{"location":"schemas/basictype/#enum-element","text":"Type: integer path: #/properties/Value/items","title":"Enum Element"},{"location":"schemas/infotype/","text":"InfoType InfoTypes describe composite objects, containing one or multiple BasicInfoTypes or InfoTypes. InfoTypes can either be objects , meaning they are composed of multiple different other types, or they can represent an array , so a well defined collection of multiple instances of the same type. Schema All fields from the General Schema are included Taxonomies Taxonomy nodes that this type should be assigned to. Type: array path: #/properties/Taxonomies Items path: #/properties/Taxonomies/items","title":"Info Types"},{"location":"schemas/infotype/#infotype","text":"InfoTypes describe composite objects, containing one or multiple BasicInfoTypes or InfoTypes. InfoTypes can either be objects , meaning they are composed of multiple different other types, or they can represent an array , so a well defined collection of multiple instances of the same type.","title":"InfoType"},{"location":"schemas/infotype/#schema","text":"All fields from the General Schema are included Taxonomies Taxonomy nodes that this type should be assigned to. Type: array path: #/properties/Taxonomies Items path: #/properties/Taxonomies/items","title":"Schema"},{"location":"schemas/measurementunit/","text":"Measurement Unit This schema describes measurement units. A MeasurementUnit can be used just as themselves or be assigned to BasicInfoTypes to create a better defined type. Schema All fields from the General Schema are included Taxonomies Taxonomy nodes that this type should be assigned to. Type: array path: #/properties/Taxonomies Items path: #/properties/Taxonomies/items unitDescription Type: object path: #/properties/unitDescription Properties Name Name of the Unit Type: string path: #/properties/unitDescription/properties/Name Symbol Symbol to describe the unit. A prefix symbol attached to a unit symbol (e.g. 'km', 'cm') constitutes a new inseparable unit symbol. Type: string path: #/properties/unitDescription/properties/Symbol Quantity The physical quanitity measured using the unit. Type: string path: #/properties/unitDescription/properties/Quantity Dimension Symbol The dimensional symbol used for the physical quantity. Type: string path: #/properties/unitDescription/properties/Dimension Symbol TypicalSymbols Other typical symbols to describe the measured quantity. Type: array path: #/properties/unitDescription/properties/TypicalSymbols Items Type: string path: #/properties/unitDescription/properties/TypicalSymbols/items Context Context where this unit is measured or used. Type: string path: #/properties/unitDescription/properties/Context Definition A short definition of the unit. Type: string path: #/properties/unitDescription/properties/Definition String format must be a \"textarea\" Usage How the unit is used in research. Type: string path: #/properties/unitDescription/properties/Usage String format must be a \"textarea\"","title":"Measurement Units"},{"location":"schemas/measurementunit/#measurement-unit","text":"This schema describes measurement units. A MeasurementUnit can be used just as themselves or be assigned to BasicInfoTypes to create a better defined type.","title":"Measurement Unit"},{"location":"schemas/measurementunit/#schema","text":"All fields from the General Schema are included Taxonomies Taxonomy nodes that this type should be assigned to. Type: array path: #/properties/Taxonomies Items path: #/properties/Taxonomies/items unitDescription Type: object path: #/properties/unitDescription Properties Name Name of the Unit Type: string path: #/properties/unitDescription/properties/Name Symbol Symbol to describe the unit. A prefix symbol attached to a unit symbol (e.g. 'km', 'cm') constitutes a new inseparable unit symbol. Type: string path: #/properties/unitDescription/properties/Symbol Quantity The physical quanitity measured using the unit. Type: string path: #/properties/unitDescription/properties/Quantity Dimension Symbol The dimensional symbol used for the physical quantity. Type: string path: #/properties/unitDescription/properties/Dimension Symbol TypicalSymbols Other typical symbols to describe the measured quantity. Type: array path: #/properties/unitDescription/properties/TypicalSymbols Items Type: string path: #/properties/unitDescription/properties/TypicalSymbols/items Context Context where this unit is measured or used. Type: string path: #/properties/unitDescription/properties/Context Definition A short definition of the unit. Type: string path: #/properties/unitDescription/properties/Definition String format must be a \"textarea\" Usage How the unit is used in research. Type: string path: #/properties/unitDescription/properties/Usage String format must be a \"textarea\"","title":"Schema"},{"location":"schemas/taxonomynode/","text":"TaxonomyNode TaxonomyNodes describe a hierarchical structure of vocabularies. Any other prepared schema type can assigned one or more TaxonomyNodes . Via the TypeAPI , Taxonomies can resolved and all types returned that are somewhere in the subtree of the selected TaxonomyNode . Schema All fields from the General Schema are included reference External reference to the taxonomy node. Type: string path: #/properties/reference parents Type: array path: #/properties/parents Items path: #/properties/parents/items","title":"Taxonomy Nodes"},{"location":"schemas/taxonomynode/#taxonomynode","text":"TaxonomyNodes describe a hierarchical structure of vocabularies. Any other prepared schema type can assigned one or more TaxonomyNodes . Via the TypeAPI , Taxonomies can resolved and all types returned that are somewhere in the subtree of the selected TaxonomyNode .","title":"TaxonomyNode"},{"location":"schemas/taxonomynode/#schema","text":"All fields from the General Schema are included reference External reference to the taxonomy node. Type: string path: #/properties/reference parents Type: array path: #/properties/parents Items path: #/properties/parents/items","title":"Schema"}]}