{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Get Started Welcome to the documentation of the data type registry developed in the scope of the FAIRCORE4EOSC project. The Typeregistry is based on the Cordra software developed by CNRI. Cordra is a software to manage digital objects and equip them with a persistent identifier. These digital objects are represented as JSON objects based on some previously defined JSON schema. In this typeregistry, some schemas are provided to cover many use cases. For more information on the provided schemas, refer to later pages in this documentation. Created types are equipped with a handle PID for unambigous identification of data types. Types can be created via the user interface or an API. For this, Cordra offers a REST API and a DOIP API for HTTP Clients. Documentation for these API's is provided by Cordra and can be found under the Documentation tab on the navigation bar. How the most basic operations can be used in the context of the Typeregistry can be found on the next page. To get started creating types, an account is necessary. As for now, no login via some external AAI provider is integrated in the typeregistry. Rather, a request has to be send for the admin to create an account for you. To request an account, please send a mail to support@pidconsortium.net . Should you just want to experiment with the provided schemas, we also offer the DTR-Playground . Here, the same interface with the same schemas is provided, but no persistent identifiers are generated for the data types and a user account is not required for the type creation. TypeAPI The TypeAPI is an additional service that is provided as part of the DTR component. Here, further functionalities are supplemented to types of the provided schemas to increase their effective use. These additional functionalities include the generation of validation schemas for types that qualify, filtering of types based on the measurement unit they use or which taxonomy node they are assigned to, and a federated search over mutltiple registries. These additional regisitries currently include the DTR- Test and the DTR-PIT by the pidconsortium. An extensive documentation of all available endpoints can also be found under the Documentation tab on the navigation bar.","title":"Get Started"},{"location":"#get-started","text":"Welcome to the documentation of the data type registry developed in the scope of the FAIRCORE4EOSC project. The Typeregistry is based on the Cordra software developed by CNRI. Cordra is a software to manage digital objects and equip them with a persistent identifier. These digital objects are represented as JSON objects based on some previously defined JSON schema. In this typeregistry, some schemas are provided to cover many use cases. For more information on the provided schemas, refer to later pages in this documentation. Created types are equipped with a handle PID for unambigous identification of data types. Types can be created via the user interface or an API. For this, Cordra offers a REST API and a DOIP API for HTTP Clients. Documentation for these API's is provided by Cordra and can be found under the Documentation tab on the navigation bar. How the most basic operations can be used in the context of the Typeregistry can be found on the next page. To get started creating types, an account is necessary. As for now, no login via some external AAI provider is integrated in the typeregistry. Rather, a request has to be send for the admin to create an account for you. To request an account, please send a mail to support@pidconsortium.net . Should you just want to experiment with the provided schemas, we also offer the DTR-Playground . Here, the same interface with the same schemas is provided, but no persistent identifiers are generated for the data types and a user account is not required for the type creation.","title":"Get Started"},{"location":"#typeapi","text":"The TypeAPI is an additional service that is provided as part of the DTR component. Here, further functionalities are supplemented to types of the provided schemas to increase their effective use. These additional functionalities include the generation of validation schemas for types that qualify, filtering of types based on the measurement unit they use or which taxonomy node they are assigned to, and a federated search over mutltiple registries. These additional regisitries currently include the DTR- Test and the DTR-PIT by the pidconsortium. An extensive documentation of all available endpoints can also be found under the Documentation tab on the navigation bar.","title":"TypeAPI"},{"location":"apiIntro/","text":"API Introduction For the work with the typeregistry, the use of API's is an important feature to handle larger datasets or if you just have no need for the user interface. To begin, an account is necessary for most operations. Once you have an account, you can generate an access token using the following command: curl --request POST \\ --url 'http://typeregistry.lab.pidconsortium.net/auth/token' \\ --header 'Content-Type: application/json' \\ --data '{ \"grant_type\": \"password\", \"username\": \"\", \"password\": \"\" }' Enter your username and password in the designated fields. The token can be retrieved from the access_token field in the response. This token will stay active during your session and can be used for multiple requests. The retrieve command is one of the simplest ones and just requires the URL of the object you want to retrieve. Note that a # in front of objects in the URL would direct you to the UI version of the type. curl --request GET \\ --url 'http://typeregistry.lab.pidconsortium.net/objects/21.T11969/a41d30cdc6206b5a6fdd' \\ --header 'Content-Type: application/json' Some types are only visible for authorized users. For those types we will use the generated token to authenticate ourselves. This will be done in an 'Authorization' Header field, where TOKEN is the access token you generated for your account. curl --request GET \\ --url 'http://typeregistry.lab.pidconsortium.net/objects/21.T11969/0ea269895eceaf41f7d2' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Bearer TOKEN' Another important use of the API involves the creation of types via the API. This is helpful for larger batches of data or if you do not wish to work via the UI. Since Cordra stores types as JSON objects, we have to create JSON Objects based on the schemas provided. For more information on the schemas please refer to the respective sections in the documentations or view them directly under Types in the navigation bar. If you create a type via the API ist must be valid for the desired schema. An example for a type that is a valid BasicInfoType can be for example the following. Note that no field for id is given in the JSON object. This will be automatically filled and is part of the response. { \"name\": \"TestType\", \"provenance\": { \"contributors\": [ { \"Name\": \"Type Typerman\" } ], \"creationDate\": \"\", \"lastModificationDate\": \"\" }, \"ExpectedUse\": \"Will demonstrate API\", \"Aliases\": [ \"TestFile\" ], \"MeasuredUnits\": [ \"21.T11969/a41d30cdc6206b5a6fdd\" ], \"Schema\": { \"Type\": \"String\", \"Properties\": [ { \"Property\": \"minLength\", \"Value\": 0 }, { \"Property\": \"maxLength\", \"Value\": 10 } ] } } Consider this object saved on your disk as testType.json . To now create a type with that content consider the following command: curl --request POST \\ --url 'http://typeregistry.lab.pidconsortium.net/objects/?type=BasicInfoType' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Bearer TOKEN' \\ --data @\"testType.json\" Note that we need to authenticate the same way as before. The JSON object representing the type is simply passed as the content of the POST request. Of course it would also be possible to copy the actual JSON into the --data field, but referencing the file is a simpler way.","title":"API Introduction"},{"location":"apiIntro/#api-introduction","text":"For the work with the typeregistry, the use of API's is an important feature to handle larger datasets or if you just have no need for the user interface. To begin, an account is necessary for most operations. Once you have an account, you can generate an access token using the following command: curl --request POST \\ --url 'http://typeregistry.lab.pidconsortium.net/auth/token' \\ --header 'Content-Type: application/json' \\ --data '{ \"grant_type\": \"password\", \"username\": \"\", \"password\": \"\" }' Enter your username and password in the designated fields. The token can be retrieved from the access_token field in the response. This token will stay active during your session and can be used for multiple requests. The retrieve command is one of the simplest ones and just requires the URL of the object you want to retrieve. Note that a # in front of objects in the URL would direct you to the UI version of the type. curl --request GET \\ --url 'http://typeregistry.lab.pidconsortium.net/objects/21.T11969/a41d30cdc6206b5a6fdd' \\ --header 'Content-Type: application/json' Some types are only visible for authorized users. For those types we will use the generated token to authenticate ourselves. This will be done in an 'Authorization' Header field, where TOKEN is the access token you generated for your account. curl --request GET \\ --url 'http://typeregistry.lab.pidconsortium.net/objects/21.T11969/0ea269895eceaf41f7d2' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Bearer TOKEN' Another important use of the API involves the creation of types via the API. This is helpful for larger batches of data or if you do not wish to work via the UI. Since Cordra stores types as JSON objects, we have to create JSON Objects based on the schemas provided. For more information on the schemas please refer to the respective sections in the documentations or view them directly under Types in the navigation bar. If you create a type via the API ist must be valid for the desired schema. An example for a type that is a valid BasicInfoType can be for example the following. Note that no field for id is given in the JSON object. This will be automatically filled and is part of the response. { \"name\": \"TestType\", \"provenance\": { \"contributors\": [ { \"Name\": \"Type Typerman\" } ], \"creationDate\": \"\", \"lastModificationDate\": \"\" }, \"ExpectedUse\": \"Will demonstrate API\", \"Aliases\": [ \"TestFile\" ], \"MeasuredUnits\": [ \"21.T11969/a41d30cdc6206b5a6fdd\" ], \"Schema\": { \"Type\": \"String\", \"Properties\": [ { \"Property\": \"minLength\", \"Value\": 0 }, { \"Property\": \"maxLength\", \"Value\": 10 } ] } } Consider this object saved on your disk as testType.json . To now create a type with that content consider the following command: curl --request POST \\ --url 'http://typeregistry.lab.pidconsortium.net/objects/?type=BasicInfoType' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Bearer TOKEN' \\ --data @\"testType.json\" Note that we need to authenticate the same way as before. The JSON object representing the type is simply passed as the content of the POST request. Of course it would also be possible to copy the actual JSON into the --data field, but referencing the file is a simpler way.","title":"API Introduction"},{"location":"schemas/Overview/","text":"Schemas Overview General Schema name please use printable ascii characters without blank Type: string path: #/properties/name The value must match this pattern: ^([!-~])+$ Length: \u2264 256 description Type: string path: #/properties/description The value must match this pattern: (.|)* Length: \u2264 8192 versioning Type: object path: #/properties/versioning Properties version Type: string path: #/properties/versioning/properties/version previousVersion path: #/properties/versioning/properties/previousVersion nextVersion path: #/properties/versioning/properties/nextVersion provenance Type: object path: #/properties/provenance Properties contributors Type: array path: #/properties/provenance/properties/contributors Items Type: object path: #/properties/provenance/properties/contributors/items Properties Name Full name of the contributor Type: string path: #/properties/provenance/properties/contributors/items/properties/Name ORCID Type: string path: #/properties/provenance/properties/contributors/items/properties/ORCID creationDate Type: string path: #/properties/provenance/properties/creationDate String format must be a \"datetime\" lastModificationDate Type: string path: #/properties/provenance/properties/lastModificationDate String format must be a \"datetime\" ExpectedUse Type: string path: #/properties/ExpectedUse String format must be a \"textarea\" Length: \u2264 1024 Aliases Provide a list of aliases as alternatives to the chosen name. Type: array path: #/properties/Aliases Items Type: string path: #/properties/Aliases/items","title":"Schemas Overview"},{"location":"schemas/Overview/#schemas-overview","text":"","title":"Schemas Overview"},{"location":"schemas/Overview/#general-schema","text":"name please use printable ascii characters without blank Type: string path: #/properties/name The value must match this pattern: ^([!-~])+$ Length: \u2264 256 description Type: string path: #/properties/description The value must match this pattern: (.|)* Length: \u2264 8192 versioning Type: object path: #/properties/versioning Properties version Type: string path: #/properties/versioning/properties/version previousVersion path: #/properties/versioning/properties/previousVersion nextVersion path: #/properties/versioning/properties/nextVersion provenance Type: object path: #/properties/provenance Properties contributors Type: array path: #/properties/provenance/properties/contributors Items Type: object path: #/properties/provenance/properties/contributors/items Properties Name Full name of the contributor Type: string path: #/properties/provenance/properties/contributors/items/properties/Name ORCID Type: string path: #/properties/provenance/properties/contributors/items/properties/ORCID creationDate Type: string path: #/properties/provenance/properties/creationDate String format must be a \"datetime\" lastModificationDate Type: string path: #/properties/provenance/properties/lastModificationDate String format must be a \"datetime\" ExpectedUse Type: string path: #/properties/ExpectedUse String format must be a \"textarea\" Length: \u2264 1024 Aliases Provide a list of aliases as alternatives to the chosen name. Type: array path: #/properties/Aliases Items Type: string path: #/properties/Aliases/items","title":"General Schema"},{"location":"schemas/basictype/","text":"BasicInfoType Schema MeasuredUnits Units that are measured using this type. Type: array path: #/properties/MeasuredUnits Items path: #/properties/MeasuredUnits/items Taxonomies Taxonomy nodes that this type should be assigned to. Type: array path: #/properties/Taxonomies Items path: #/properties/Taxonomies/items Schema Select the fundamental datatype this type should represent. \"Number\" can be further differentiated into integer and float. Type: object path: #/properties/Schema Properties The properties of the schema branch here into different directions based on the desired fundamental datatype. For each fundamental type, different restrictions are valid and internal validation is conducted accordingly. We now list the possibilities for each datatype. AnyOf : Type required For type \"Number\", further differentiate between integer and float. Type: string path: #/properties/Test/properties/Type The value is restricted to the following: \"String\" PropRelations Properties are chained by boolean operators. By default, through the AND operator all properties must apply. OR or XOR operators for properties are also possible. Type: string path: #/properties/Test/properties/PropRelations The value is restricted to the following: \"AND\" \"OR\" \"XOR\" Properties Type: array path: #/properties/Test/properties/Properties Items Type: object path: #/properties/Test/properties/Properties/items Properties","title":"BasicInfoType"},{"location":"schemas/basictype/#basicinfotype","text":"","title":"BasicInfoType"},{"location":"schemas/basictype/#schema","text":"MeasuredUnits Units that are measured using this type. Type: array path: #/properties/MeasuredUnits Items path: #/properties/MeasuredUnits/items Taxonomies Taxonomy nodes that this type should be assigned to. Type: array path: #/properties/Taxonomies Items path: #/properties/Taxonomies/items Schema Select the fundamental datatype this type should represent. \"Number\" can be further differentiated into integer and float. Type: object path: #/properties/Schema Properties The properties of the schema branch here into different directions based on the desired fundamental datatype. For each fundamental type, different restrictions are valid and internal validation is conducted accordingly. We now list the possibilities for each datatype. AnyOf : Type required For type \"Number\", further differentiate between integer and float. Type: string path: #/properties/Test/properties/Type The value is restricted to the following: \"String\" PropRelations Properties are chained by boolean operators. By default, through the AND operator all properties must apply. OR or XOR operators for properties are also possible. Type: string path: #/properties/Test/properties/PropRelations The value is restricted to the following: \"AND\" \"OR\" \"XOR\" Properties Type: array path: #/properties/Test/properties/Properties Items Type: object path: #/properties/Test/properties/Properties/items Properties","title":"Schema"},{"location":"schemas/infotype/","text":"InfoType mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"InfoType"},{"location":"schemas/infotype/#infotype","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"InfoType"},{"location":"schemas/measurementunit/","text":"Measurement Unit Schema Taxonomies Taxonomy nodes that this type should be assigned to. Type: array path: #/properties/Taxonomies Items path: #/properties/Taxonomies/items unitDescription Type: object path: #/properties/unitDescription Properties Name Name of the Unit Type: string path: #/properties/unitDescription/properties/Name Symbol Symbol to describe the unit. A prefix symbol attached to a unit symbol (e.g. 'km', 'cm') constitutes a new inseparable unit symbol. Type: string path: #/properties/unitDescription/properties/Symbol Quantity The physical quanitity measured using the unit. Type: string path: #/properties/unitDescription/properties/Quantity Dimension Symbol The dimensional symbol used for the physical quantity. Type: string path: #/properties/unitDescription/properties/Dimension Symbol TypicalSymbols Other typical symbols to describe the measured quantity. Type: array path: #/properties/unitDescription/properties/TypicalSymbols Items Type: string path: #/properties/unitDescription/properties/TypicalSymbols/items Context Context where this unit is measured or used. Type: string path: #/properties/unitDescription/properties/Context Definition A short definition of the unit. Type: string path: #/properties/unitDescription/properties/Definition String format must be a \"textarea\" Usage How the unit is used in research. Type: string path: #/properties/unitDescription/properties/Usage String format must be a \"textarea\"","title":"Measurement Unit"},{"location":"schemas/measurementunit/#measurement-unit","text":"","title":"Measurement Unit"},{"location":"schemas/measurementunit/#schema","text":"Taxonomies Taxonomy nodes that this type should be assigned to. Type: array path: #/properties/Taxonomies Items path: #/properties/Taxonomies/items unitDescription Type: object path: #/properties/unitDescription Properties Name Name of the Unit Type: string path: #/properties/unitDescription/properties/Name Symbol Symbol to describe the unit. A prefix symbol attached to a unit symbol (e.g. 'km', 'cm') constitutes a new inseparable unit symbol. Type: string path: #/properties/unitDescription/properties/Symbol Quantity The physical quanitity measured using the unit. Type: string path: #/properties/unitDescription/properties/Quantity Dimension Symbol The dimensional symbol used for the physical quantity. Type: string path: #/properties/unitDescription/properties/Dimension Symbol TypicalSymbols Other typical symbols to describe the measured quantity. Type: array path: #/properties/unitDescription/properties/TypicalSymbols Items Type: string path: #/properties/unitDescription/properties/TypicalSymbols/items Context Context where this unit is measured or used. Type: string path: #/properties/unitDescription/properties/Context Definition A short definition of the unit. Type: string path: #/properties/unitDescription/properties/Definition String format must be a \"textarea\" Usage How the unit is used in research. Type: string path: #/properties/unitDescription/properties/Usage String format must be a \"textarea\"","title":"Schema"},{"location":"schemas/taxonomynode/","text":"TaxonomyNode Schema reference External reference to the taxonomy node. Type: string path: #/properties/reference parents Type: array path: #/properties/parents Items path: #/properties/parents/items","title":"TaxonomyNode"},{"location":"schemas/taxonomynode/#taxonomynode","text":"","title":"TaxonomyNode"},{"location":"schemas/taxonomynode/#schema","text":"reference External reference to the taxonomy node. Type: string path: #/properties/reference parents Type: array path: #/properties/parents Items path: #/properties/parents/items","title":"Schema"}]}