{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Get Started Welcome to the documentation of the data type registry developed in the scope of the FAIRCORE4EOSC project. The Typeregistry is based on the Cordra software developed by CNRI. Cordra is a software to manage digital objects and equip them with a persistent identifier. These digital objects are represented as JSON objects based on some previously defined JSON schema. In this typeregistry, some schemas are provided to cover many use cases. For more information on the provided schemas, refer to later pages in this documentation. Created types are equipped with a handle PID for unambigous identification of data types. Types can be created via the user interface or an API. For this, Cordra offers a REST API and a DOIP API for HTTP Clients. Documentation for these API's is provided by Cordra and can be found under the Documentation tab on the navigation bar. How the most basic operations can be used in the context of the Typeregistry can be found on the next page. To get started creating types, an account is necessary. As for now, no login via some external AAI provider is integrated in the typeregistry. Rather, a request has to be send for the admin to create an account for you. To request an account, please send a mail to support@pidconsortium.net . Should you just want to experiment with the provided schemas, we also offer the DTR-Playground . Here, the same interface with the same schemas is provided, but no persistent identifiers are generated for the data types and a user account is not required for the type creation. TypeAPI The TypeAPI is an additional service that is provided as part of the DTR component. Here, further functionalities are supplemented to types of the provided schemas to increase their effective use. These additional functionalities include the generation of validation schemas for types that qualify, filtering of types based on the measurement unit they use or which taxonomy node they are assigned to, and a federated search over mutltiple registries. These additional regisitries currently include the DTR- Test and the DTR-PIT by the pidconsortium. An extensive documentation of all available endpoints can also be found under the Documentation tab on the navigation bar.","title":"Get Started"},{"location":"#get-started","text":"Welcome to the documentation of the data type registry developed in the scope of the FAIRCORE4EOSC project. The Typeregistry is based on the Cordra software developed by CNRI. Cordra is a software to manage digital objects and equip them with a persistent identifier. These digital objects are represented as JSON objects based on some previously defined JSON schema. In this typeregistry, some schemas are provided to cover many use cases. For more information on the provided schemas, refer to later pages in this documentation. Created types are equipped with a handle PID for unambigous identification of data types. Types can be created via the user interface or an API. For this, Cordra offers a REST API and a DOIP API for HTTP Clients. Documentation for these API's is provided by Cordra and can be found under the Documentation tab on the navigation bar. How the most basic operations can be used in the context of the Typeregistry can be found on the next page. To get started creating types, an account is necessary. As for now, no login via some external AAI provider is integrated in the typeregistry. Rather, a request has to be send for the admin to create an account for you. To request an account, please send a mail to support@pidconsortium.net . Should you just want to experiment with the provided schemas, we also offer the DTR-Playground . Here, the same interface with the same schemas is provided, but no persistent identifiers are generated for the data types and a user account is not required for the type creation.","title":"Get Started"},{"location":"#typeapi","text":"The TypeAPI is an additional service that is provided as part of the DTR component. Here, further functionalities are supplemented to types of the provided schemas to increase their effective use. These additional functionalities include the generation of validation schemas for types that qualify, filtering of types based on the measurement unit they use or which taxonomy node they are assigned to, and a federated search over mutltiple registries. These additional regisitries currently include the DTR- Test and the DTR-PIT by the pidconsortium. An extensive documentation of all available endpoints can also be found under the Documentation tab on the navigation bar.","title":"TypeAPI"},{"location":"Tutorials/apiIntro/","text":"Cordra API Introduction For the work with the typeregistry, the use of API's is an important feature to handle larger datasets or if you just have no need for the user interface. To begin, an account is necessary for most operations. Once you have an account, you can generate an access token using the following command: curl --request POST \\ --url 'http://typeregistry.lab.pidconsortium.net/auth/token' \\ --header 'Content-Type: application/json' \\ --data '{ \"grant_type\": \"password\", \"username\": \"\", \"password\": \"\" }' Enter your username and password in the designated fields. The token can be retrieved from the access_token field in the response. This token will stay active during your session and can be used for multiple requests. The retrieve command is one of the simplest ones and just requires the URL of the object you want to retrieve. Note that a # in front of objects in the URL would direct you to the UI version of the type. curl --request GET \\ --url 'http://typeregistry.lab.pidconsortium.net/objects/21.T11969/a41d30cdc6206b5a6fdd' \\ --header 'Content-Type: application/json' Some types are only visible for authorized users. For those types we will use the generated token to authenticate ourselves. This will be done in an 'Authorization' Header field, where TOKEN is the access token you generated for your account. curl --request GET \\ --url 'http://typeregistry.lab.pidconsortium.net/objects/21.T11969/0ea269895eceaf41f7d2' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Bearer TOKEN' Another important use of the API involves the creation of types via the API. This is helpful for larger batches of data or if you do not wish to work via the UI. Since Cordra stores types as JSON objects, we have to create JSON Objects based on the schemas provided. For more information on the schemas please refer to the respective sections in the documentations or view them directly under Types in the navigation bar. If you create a type via the API ist must be valid for the desired schema. An example for a type that is a valid BasicInfoType can be for example the following. Note that no field for id is given in the JSON object. This will be automatically filled and is part of the response. { \"name\": \"TestType\", \"provenance\": { \"contributors\": [ { \"Name\": \"Type Typerman\" } ], \"creationDate\": \"\", \"lastModificationDate\": \"\" }, \"ExpectedUse\": \"Will demonstrate API\", \"Aliases\": [ \"TestFile\" ], \"MeasuredUnits\": [ \"21.T11969/a41d30cdc6206b5a6fdd\" ], \"Schema\": { \"Type\": \"String\", \"Properties\": [ { \"Property\": \"minLength\", \"Value\": 0 }, { \"Property\": \"maxLength\", \"Value\": 10 } ] } } Consider this object saved on your disk as testType.json . To now create a type with that content consider the following command: curl --request POST \\ --url 'http://typeregistry.lab.pidconsortium.net/objects/?type=BasicInfoType' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Bearer TOKEN' \\ --data @\"testType.json\" Note that we need to authenticate the same way as before. The JSON object representing the type is simply passed as the content of the POST request. Of course it would also be possible to copy the actual JSON into the --data field, but referencing the file is a simpler way. For more information on the Cordra API refer to the links in the Documentation tab.","title":"Cordra API Introduction"},{"location":"Tutorials/apiIntro/#cordra-api-introduction","text":"For the work with the typeregistry, the use of API's is an important feature to handle larger datasets or if you just have no need for the user interface. To begin, an account is necessary for most operations. Once you have an account, you can generate an access token using the following command: curl --request POST \\ --url 'http://typeregistry.lab.pidconsortium.net/auth/token' \\ --header 'Content-Type: application/json' \\ --data '{ \"grant_type\": \"password\", \"username\": \"\", \"password\": \"\" }' Enter your username and password in the designated fields. The token can be retrieved from the access_token field in the response. This token will stay active during your session and can be used for multiple requests. The retrieve command is one of the simplest ones and just requires the URL of the object you want to retrieve. Note that a # in front of objects in the URL would direct you to the UI version of the type. curl --request GET \\ --url 'http://typeregistry.lab.pidconsortium.net/objects/21.T11969/a41d30cdc6206b5a6fdd' \\ --header 'Content-Type: application/json' Some types are only visible for authorized users. For those types we will use the generated token to authenticate ourselves. This will be done in an 'Authorization' Header field, where TOKEN is the access token you generated for your account. curl --request GET \\ --url 'http://typeregistry.lab.pidconsortium.net/objects/21.T11969/0ea269895eceaf41f7d2' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Bearer TOKEN' Another important use of the API involves the creation of types via the API. This is helpful for larger batches of data or if you do not wish to work via the UI. Since Cordra stores types as JSON objects, we have to create JSON Objects based on the schemas provided. For more information on the schemas please refer to the respective sections in the documentations or view them directly under Types in the navigation bar. If you create a type via the API ist must be valid for the desired schema. An example for a type that is a valid BasicInfoType can be for example the following. Note that no field for id is given in the JSON object. This will be automatically filled and is part of the response. { \"name\": \"TestType\", \"provenance\": { \"contributors\": [ { \"Name\": \"Type Typerman\" } ], \"creationDate\": \"\", \"lastModificationDate\": \"\" }, \"ExpectedUse\": \"Will demonstrate API\", \"Aliases\": [ \"TestFile\" ], \"MeasuredUnits\": [ \"21.T11969/a41d30cdc6206b5a6fdd\" ], \"Schema\": { \"Type\": \"String\", \"Properties\": [ { \"Property\": \"minLength\", \"Value\": 0 }, { \"Property\": \"maxLength\", \"Value\": 10 } ] } } Consider this object saved on your disk as testType.json . To now create a type with that content consider the following command: curl --request POST \\ --url 'http://typeregistry.lab.pidconsortium.net/objects/?type=BasicInfoType' \\ --header 'Content-Type: application/json' \\ --header 'Authorization: Bearer TOKEN' \\ --data @\"testType.json\" Note that we need to authenticate the same way as before. The JSON object representing the type is simply passed as the content of the POST request. Of course it would also be possible to copy the actual JSON into the --data field, but referencing the file is a simpler way. For more information on the Cordra API refer to the links in the Documentation tab.","title":"Cordra API Introduction"},{"location":"Tutorials/schemaTypeTutorial/","text":"Creating Schema Elements from Scratch One main application of the Data Type Registry is the creation of metadata elements of schemas. Registering metadata elements has many advantages. These include the unambigious identification via a PID, additional metadata information, and the possibility of reusability and interoperability of types. In this tutorial, we will walk through the entire creation of schema elements, starting with the fundamental building blocks and ending at the generation of JSON schemas of complex data types. What are Schema Elements in the DTR? When clicking Create , the possible types that are available can seem overwhelming at first. That is why we want to shed some light on the kinds of data types relevant for the creation of schema elements. In general, we differentiate between two different structures with different responsibilities. BasicInfoTypes can be considered the basic building blocks, or leaf nodes, for schema elements. Each BasicInfoType is simply some fundamental data type, with additional metadata and the possibility to apply some restrictions on that type. An InfoType on the other hand is a more complex construct. It shares the set of metadata with BasicInfoTypes , but instead of a fundamental data type it represents a composite of other types. It can either take the form of an Object , which is basically a set of key - value pairs where the values are other types, or an Array , where one type can be repeated. The Tuple property will be implemented soon. The following table gives a quick overview over which type can represent what: BasicInfoType InfoType String Object Number Array Boolean Tuple We will start now by creating a BasicInfoType to descibe a single property of an existing metadata schema. Creating a BasicInfoType For the creation of our BasicInfoType we will use an actual metadata schema as a blueprint. This hopefully helps in following along the parallels and how the schema is created hierarchically in the DTR. Take a look at the following schema from KonsortSWD, which develop infrastructure for research data for the social sciences in the scope of the NFDI. When untangling the $ref properties we see that the schema is basically an object containing just an array called variables , where each variable has a number of properties. To now recreate this schema in the DTR we have to start from the bottom and gradually build the schema up hierarchically. So let us zoom in on one of those basic properties, the first one in the list: \"studyDOI\": {\"type\": \"string\",\"pattern\": \"[1][0][/.].*\"}, We see that it represents the fundamental data type string and applies a restriction in the form of a regular expression, just called pattern in JSON-Schema. Now we want to create this property as BasicInfoType in the DTR. Of course this is all possible via the API, but we consider the process via the UI for now. Take a look at tje [] Generating a JSON Schema Lorem Ipsum Creating an Info Type Effects of the different fields on the Schema","title":"Creating Schema Elements from Scratch"},{"location":"Tutorials/schemaTypeTutorial/#creating-schema-elements-from-scratch","text":"One main application of the Data Type Registry is the creation of metadata elements of schemas. Registering metadata elements has many advantages. These include the unambigious identification via a PID, additional metadata information, and the possibility of reusability and interoperability of types. In this tutorial, we will walk through the entire creation of schema elements, starting with the fundamental building blocks and ending at the generation of JSON schemas of complex data types.","title":"Creating Schema Elements from Scratch"},{"location":"Tutorials/schemaTypeTutorial/#what-are-schema-elements-in-the-dtr","text":"When clicking Create , the possible types that are available can seem overwhelming at first. That is why we want to shed some light on the kinds of data types relevant for the creation of schema elements. In general, we differentiate between two different structures with different responsibilities. BasicInfoTypes can be considered the basic building blocks, or leaf nodes, for schema elements. Each BasicInfoType is simply some fundamental data type, with additional metadata and the possibility to apply some restrictions on that type. An InfoType on the other hand is a more complex construct. It shares the set of metadata with BasicInfoTypes , but instead of a fundamental data type it represents a composite of other types. It can either take the form of an Object , which is basically a set of key - value pairs where the values are other types, or an Array , where one type can be repeated. The Tuple property will be implemented soon. The following table gives a quick overview over which type can represent what: BasicInfoType InfoType String Object Number Array Boolean Tuple We will start now by creating a BasicInfoType to descibe a single property of an existing metadata schema.","title":"What are Schema Elements in the DTR?"},{"location":"Tutorials/schemaTypeTutorial/#creating-a-basicinfotype","text":"For the creation of our BasicInfoType we will use an actual metadata schema as a blueprint. This hopefully helps in following along the parallels and how the schema is created hierarchically in the DTR. Take a look at the following schema from KonsortSWD, which develop infrastructure for research data for the social sciences in the scope of the NFDI. When untangling the $ref properties we see that the schema is basically an object containing just an array called variables , where each variable has a number of properties. To now recreate this schema in the DTR we have to start from the bottom and gradually build the schema up hierarchically. So let us zoom in on one of those basic properties, the first one in the list: \"studyDOI\": {\"type\": \"string\",\"pattern\": \"[1][0][/.].*\"}, We see that it represents the fundamental data type string and applies a restriction in the form of a regular expression, just called pattern in JSON-Schema. Now we want to create this property as BasicInfoType in the DTR. Of course this is all possible via the API, but we consider the process via the UI for now. Take a look at tje []","title":"Creating a BasicInfoType"},{"location":"Tutorials/schemaTypeTutorial/#generating-a-json-schema","text":"Lorem Ipsum","title":"Generating a JSON Schema"},{"location":"Tutorials/schemaTypeTutorial/#creating-an-info-type","text":"","title":"Creating an Info Type"},{"location":"Tutorials/schemaTypeTutorial/#effects-of-the-different-fields-on-the-schema","text":"","title":"Effects of the different fields on the Schema"},{"location":"schemas/Overview/","text":"Schemas Overview All schemas that are included in the Typeregistry share a common set of metadata that are used to describe the types. For an easier overview, this set of metadata is described here once and omitted from the individual definitions. General Schema name please use printable ascii characters without blank Type: string path: #/properties/name The value must match this pattern: ^([!-~])+$ Length: \u2264 256 description Type: string path: #/properties/description The value must match this pattern: (.|)* Length: \u2264 8192 versioning Type: object path: #/properties/versioning Properties version Type: string path: #/properties/versioning/properties/version previousVersion path: #/properties/versioning/properties/previousVersion nextVersion path: #/properties/versioning/properties/nextVersion provenance Type: object path: #/properties/provenance Properties contributors Type: array path: #/properties/provenance/properties/contributors Items Type: object path: #/properties/provenance/properties/contributors/items Properties Name Full name of the contributor Type: string path: #/properties/provenance/properties/contributors/items/properties/Name ORCID Type: string path: #/properties/provenance/properties/contributors/items/properties/ORCID creationDate Type: string path: #/properties/provenance/properties/creationDate String format must be a \"datetime\" lastModificationDate Type: string path: #/properties/provenance/properties/lastModificationDate String format must be a \"datetime\" ExpectedUse Type: string path: #/properties/ExpectedUse String format must be a \"textarea\" Length: \u2264 1024 Aliases Provide a list of aliases as alternatives to the chosen name. Type: array path: #/properties/Aliases Items Type: string path: #/properties/Aliases/items","title":"Schemas Overview"},{"location":"schemas/Overview/#schemas-overview","text":"All schemas that are included in the Typeregistry share a common set of metadata that are used to describe the types. For an easier overview, this set of metadata is described here once and omitted from the individual definitions.","title":"Schemas Overview"},{"location":"schemas/Overview/#general-schema","text":"name please use printable ascii characters without blank Type: string path: #/properties/name The value must match this pattern: ^([!-~])+$ Length: \u2264 256 description Type: string path: #/properties/description The value must match this pattern: (.|)* Length: \u2264 8192 versioning Type: object path: #/properties/versioning Properties version Type: string path: #/properties/versioning/properties/version previousVersion path: #/properties/versioning/properties/previousVersion nextVersion path: #/properties/versioning/properties/nextVersion provenance Type: object path: #/properties/provenance Properties contributors Type: array path: #/properties/provenance/properties/contributors Items Type: object path: #/properties/provenance/properties/contributors/items Properties Name Full name of the contributor Type: string path: #/properties/provenance/properties/contributors/items/properties/Name ORCID Type: string path: #/properties/provenance/properties/contributors/items/properties/ORCID creationDate Type: string path: #/properties/provenance/properties/creationDate String format must be a \"datetime\" lastModificationDate Type: string path: #/properties/provenance/properties/lastModificationDate String format must be a \"datetime\" ExpectedUse Type: string path: #/properties/ExpectedUse String format must be a \"textarea\" Length: \u2264 1024 Aliases Provide a list of aliases as alternatives to the chosen name. Type: array path: #/properties/Aliases Items Type: string path: #/properties/Aliases/items","title":"General Schema"},{"location":"schemas/basictype/","text":"BasicInfoType The BasicInfoType is used to represent any datatype that is some form of a fundamental type, namely strings, numbers, booleans. When restrictions are properly filled, a validation schema can be generated for each BasicInfoType. Schema All fields from the General Schema are included MeasuredUnits Units that are measured using this type. Type: array path: #/properties/MeasuredUnits Items path: #/properties/MeasuredUnits/items Taxonomies Taxonomy nodes that this type should be assigned to. Type: array path: #/properties/Taxonomies Items path: #/properties/Taxonomies/items Schema Select the fundamental datatype this type should represent. \"Number\" can be further differentiated into integer and float. Type: object path: #/properties/Schema Properties The properties of the schema branch here into different directions based on the desired fundamental datatype. For each fundamental type, different restrictions are valid and internal validation is conducted accordingly. We now list the possibilities for each datatype. Type required For type \"Number\", further differentiate between integer and float. Type: string path: #/properties/Test/properties/Type The value is restricted to the following: \"String\" \"Integer\" \"Number\" \"Boolean\" \"Enum\" \"None\" PropRelations Properties are chained by boolean operators. By default, through the AND operator all properties must apply. OR or XOR operators for properties are also possible. Type: string path: #/properties/Test/properties/PropRelations The value is restricted to the following: \"AND\" \"OR\" \"XOR\" Properties Type: array/string path: #/properties/Test/properties/Properties The allowed values in the properties field depend on the desired fundamental type. Strings, Integers and Numbers have an array like described in the items field below. Note that when using field names described by the json-schema definition (i.e. minLength, maxLength...) the values are validated internally to avoid issues on the schema creation. Items Type: object path: #/properties/Test/properties/Properties/items Properties Property Type: string path: #/properties/Property Value - Type: string - path: #/properties/Value If the selected Type is boolean , the Properties field is only one optional string, which may take one of the following two values. Type: string \"Always True\" \"Always False\" Type: string path: #/properties/Property The value is restricted to the following: \"Integer Enum\" - Value Type: array path: #/properties/Value Items Enum Element Type: integer path: #/properties/Value/items","title":"BasicInfoType"},{"location":"schemas/basictype/#basicinfotype","text":"The BasicInfoType is used to represent any datatype that is some form of a fundamental type, namely strings, numbers, booleans. When restrictions are properly filled, a validation schema can be generated for each BasicInfoType.","title":"BasicInfoType"},{"location":"schemas/basictype/#schema","text":"All fields from the General Schema are included MeasuredUnits Units that are measured using this type. Type: array path: #/properties/MeasuredUnits Items path: #/properties/MeasuredUnits/items Taxonomies Taxonomy nodes that this type should be assigned to. Type: array path: #/properties/Taxonomies Items path: #/properties/Taxonomies/items Schema Select the fundamental datatype this type should represent. \"Number\" can be further differentiated into integer and float. Type: object path: #/properties/Schema Properties The properties of the schema branch here into different directions based on the desired fundamental datatype. For each fundamental type, different restrictions are valid and internal validation is conducted accordingly. We now list the possibilities for each datatype. Type required For type \"Number\", further differentiate between integer and float. Type: string path: #/properties/Test/properties/Type The value is restricted to the following: \"String\" \"Integer\" \"Number\" \"Boolean\" \"Enum\" \"None\" PropRelations Properties are chained by boolean operators. By default, through the AND operator all properties must apply. OR or XOR operators for properties are also possible. Type: string path: #/properties/Test/properties/PropRelations The value is restricted to the following: \"AND\" \"OR\" \"XOR\" Properties Type: array/string path: #/properties/Test/properties/Properties The allowed values in the properties field depend on the desired fundamental type. Strings, Integers and Numbers have an array like described in the items field below. Note that when using field names described by the json-schema definition (i.e. minLength, maxLength...) the values are validated internally to avoid issues on the schema creation. Items Type: object path: #/properties/Test/properties/Properties/items Properties Property Type: string path: #/properties/Property Value - Type: string - path: #/properties/Value If the selected Type is boolean , the Properties field is only one optional string, which may take one of the following two values. Type: string \"Always True\" \"Always False\" Type: string path: #/properties/Property The value is restricted to the following: \"Integer Enum\" - Value Type: array path: #/properties/Value Items","title":"Schema"},{"location":"schemas/basictype/#enum-element","text":"Type: integer path: #/properties/Value/items","title":"Enum Element"},{"location":"schemas/infotype/","text":"InfoType InfoTypes describe composite objects, containing one or multiple BasicInfoTypes or InfoTypes. InfoTypes can either be objects , meaning they are composed of multiple different other types, or they can represent an array , so a well defined collection of multiple instances of the same type. Schema All fields from the General Schema are included Taxonomies Taxonomy nodes that this type should be assigned to. Type: array path: #/properties/Taxonomies Items path: #/properties/Taxonomies/items","title":"InfoType"},{"location":"schemas/infotype/#infotype","text":"InfoTypes describe composite objects, containing one or multiple BasicInfoTypes or InfoTypes. InfoTypes can either be objects , meaning they are composed of multiple different other types, or they can represent an array , so a well defined collection of multiple instances of the same type.","title":"InfoType"},{"location":"schemas/infotype/#schema","text":"All fields from the General Schema are included Taxonomies Taxonomy nodes that this type should be assigned to. Type: array path: #/properties/Taxonomies Items path: #/properties/Taxonomies/items","title":"Schema"},{"location":"schemas/measurementunit/","text":"Measurement Unit This schema describes measurement units. A MeasurementUnit can be used just as themselves or be assigned to BasicInfoTypes to create a better defined type. Schema All fields from the General Schema are included Taxonomies Taxonomy nodes that this type should be assigned to. Type: array path: #/properties/Taxonomies Items path: #/properties/Taxonomies/items unitDescription Type: object path: #/properties/unitDescription Properties Name Name of the Unit Type: string path: #/properties/unitDescription/properties/Name Symbol Symbol to describe the unit. A prefix symbol attached to a unit symbol (e.g. 'km', 'cm') constitutes a new inseparable unit symbol. Type: string path: #/properties/unitDescription/properties/Symbol Quantity The physical quanitity measured using the unit. Type: string path: #/properties/unitDescription/properties/Quantity Dimension Symbol The dimensional symbol used for the physical quantity. Type: string path: #/properties/unitDescription/properties/Dimension Symbol TypicalSymbols Other typical symbols to describe the measured quantity. Type: array path: #/properties/unitDescription/properties/TypicalSymbols Items Type: string path: #/properties/unitDescription/properties/TypicalSymbols/items Context Context where this unit is measured or used. Type: string path: #/properties/unitDescription/properties/Context Definition A short definition of the unit. Type: string path: #/properties/unitDescription/properties/Definition String format must be a \"textarea\" Usage How the unit is used in research. Type: string path: #/properties/unitDescription/properties/Usage String format must be a \"textarea\"","title":"Measurement Unit"},{"location":"schemas/measurementunit/#measurement-unit","text":"This schema describes measurement units. A MeasurementUnit can be used just as themselves or be assigned to BasicInfoTypes to create a better defined type.","title":"Measurement Unit"},{"location":"schemas/measurementunit/#schema","text":"All fields from the General Schema are included Taxonomies Taxonomy nodes that this type should be assigned to. Type: array path: #/properties/Taxonomies Items path: #/properties/Taxonomies/items unitDescription Type: object path: #/properties/unitDescription Properties Name Name of the Unit Type: string path: #/properties/unitDescription/properties/Name Symbol Symbol to describe the unit. A prefix symbol attached to a unit symbol (e.g. 'km', 'cm') constitutes a new inseparable unit symbol. Type: string path: #/properties/unitDescription/properties/Symbol Quantity The physical quanitity measured using the unit. Type: string path: #/properties/unitDescription/properties/Quantity Dimension Symbol The dimensional symbol used for the physical quantity. Type: string path: #/properties/unitDescription/properties/Dimension Symbol TypicalSymbols Other typical symbols to describe the measured quantity. Type: array path: #/properties/unitDescription/properties/TypicalSymbols Items Type: string path: #/properties/unitDescription/properties/TypicalSymbols/items Context Context where this unit is measured or used. Type: string path: #/properties/unitDescription/properties/Context Definition A short definition of the unit. Type: string path: #/properties/unitDescription/properties/Definition String format must be a \"textarea\" Usage How the unit is used in research. Type: string path: #/properties/unitDescription/properties/Usage String format must be a \"textarea\"","title":"Schema"},{"location":"schemas/taxonomynode/","text":"TaxonomyNode TaxonomyNodes describe a hierarchical structure of vocabularies. Any other prepared schema type can assigned one or more TaxonomyNodes . Via the TypeAPI , Taxonomies can resolved and all types returned that are somewhere in the subtree of the selected TaxonomyNode . Schema All fields from the General Schema are included reference External reference to the taxonomy node. Type: string path: #/properties/reference parents Type: array path: #/properties/parents Items path: #/properties/parents/items","title":"TaxonomyNode"},{"location":"schemas/taxonomynode/#taxonomynode","text":"TaxonomyNodes describe a hierarchical structure of vocabularies. Any other prepared schema type can assigned one or more TaxonomyNodes . Via the TypeAPI , Taxonomies can resolved and all types returned that are somewhere in the subtree of the selected TaxonomyNode .","title":"TaxonomyNode"},{"location":"schemas/taxonomynode/#schema","text":"All fields from the General Schema are included reference External reference to the taxonomy node. Type: string path: #/properties/reference parents Type: array path: #/properties/parents Items path: #/properties/parents/items","title":"Schema"}]}